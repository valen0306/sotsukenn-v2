# JSライブラリ向け `.d.ts` 自動整備による下流TypeScript移行支援  
研究概要と方針（案） / 2025-12-25

## 1. 背景
- JavaScript（JS）からTypeScript（TS）への移行は広く進んでいる一方で、**大規模コードベースの完全移行には大きな工数**が必要である。
- 移行が滞る主要因の一つとして、**依存ライブラリがJSのみで型定義（`.d.ts`）を提供しない**ケースが多く、下流（利用側）でTSを導入しても型検査が成立しない問題がある。

## 2. 目的
本研究は、**JSライブラリに対する型定義（`.d.ts`）整備を自動支援**し、下流プロジェクトにおけるTS導入の障壁（依存の型欠如）を低減することを目的とする。

特に、型予測の局所的な一致率だけでなく、**下流プロジェクトが実際に`tsc`を通るか**を成功基準として評価する。
この評価観点はTypeWeaverが強調する「高い局所精度 ≠ 移行成功」という主張に整合する。  
- TypeWeaver: `https://drops.dagstuhl.de/storage/00lipics/lipics-vol263-ecoop2023/LIPIcs.ECOOP.2023.37/LIPIcs.ECOOP.2023.37.pdf`

## 3. 研究課題（Research Questions）
- **RQ1（実用効果）**: JSライブラリに生成した`.d.ts`を注入することで、下流プロジェクトの**`tsc`成功率（型検査成功率）**はどれだけ改善するか。
- **RQ2（「anyで通しただけ」への反証）**: 改善はトリビアル型（例: `any`）の濫用ではないか。**トリビアル型割合**や**エラー内訳**から、モデル条件の価値を検証できるか。
- **RQ3（失敗要因）**: 失敗はどのTSエラーコードに集中し、どの種類が増減するか。典型パターンを抽出できるか。

## 4. 対象とスコープ
### 4.1 対象
- **型定義を提供しない（または不十分な）JSライブラリ**
- そのライブラリを利用する**下流TS/JSプロジェクト**

### 4.2 スコープ（やること / やらないこと）
- 本研究の主対象は「JS→TSへの全面変換」ではなく、**依存としての`.d.ts`整備（library typing）**である。
- `.d.ts`生成は **下流使用例駆動（Usage-driven）** を基本方針とし、下流に現れる呼び出し方から公開APIのシグネチャを復元する。
- 解析はまず **同一ファイル内中心（intra-file）** とし、全プログラム解析・動的アクセス（例: `obj[key]`）の完全解決は対象外とする。

## 5. 手法概要（Usage-driven `.d.ts` synthesis）
### 5.1 下流からの使用例（evidence）抽出（静的解析）
下流プロジェクトから次の情報を抽出し、型生成の根拠（constraints/evidence）として正規化する。
- import/require形（default/namespace/named/CJS分割代入 等）
- 参照イベント（関数呼び出し、メソッド呼び出し、プロパティ参照、`new`、Promise/`await`利用、`.then` 等）
- 引数の形（リテラル、オブジェクトリテラルのキー集合、コールバックの引数数/内部参照 等）
- 戻り値の使われ方（`await`、`then`内の利用、プロパティ参照 等）

### 5.2 `.d.ts`生成
- 収集したevidenceを入力として、条件（後述）ごとに`.d.ts`を生成する。
- モデル出力に対して、構文的に不正な型を除去・修正する（sanitization）。
- 生成物は「下流の型検査を成立させる」ことを目的に、公開API中心に宣言する。

### 5.3 `.d.ts`注入と`tsc`評価
- 下流プロジェクトに対し`.d.ts`を注入し、`tsc --noEmit`を実行する。
- 条件間で成功率・失敗理由を比較し、改善の要因を分析する。

## 6. 実験条件（比較）
下流に注入する`.d.ts`の生成方法を条件として固定し比較する。
- **BASELINE（注入なし）**: `.d.ts`を追加しない。
- **DTS_STUB**: 最小限の安全スタブ（例: export形状のみ合わせ、型は主に`any`/`unknown`など）を注入する。
- **DTS_MODEL**: 既存BERT系モデル（例: TypeBERT等）により推論して生成した`.d.ts`を注入する。

## 7. データセット構築（観測→抽出→確証）
本研究の評価は「ライブラリの型推論（`.d.ts` 整備）が、下流の `tsc` 成否・エラー内訳をどう変えるか」に帰着する。  
したがって、データセット構築では **(A) まず実プロジェクトで `tsc` エラー分布を観測**し、(B) そこから **「依存ライブラリ境界で起きている」失敗**を抽出し、(C) 可能なら **介入（`.d.ts` 注入）で原因を確証**する、という順で定義する。

### 7.1 観測（広く回す）
- GitHub等から一定数のプロジェクトを収集し、`tsc`（または `npm run typecheck`）を実行して **TSエラーコード分布**と **どのrepoで何が出たか**を記録する。
- この段階では「TSコードが出ていない（`tsc`成功）」や「設定/構造で実行できない（スキップ）」も含めて観測し、後段の抽出条件を設計する。

### 7.2 抽出（評価用の集合を明示）
観測結果から、評価対象集合を二層に分ける（TypeWeaverの“パッケージ単位でtypecheckを通す”評価に整合）。

- **集合 S_err（TSコード観測集合）**: `tsc` の出力に **TSxxxx** が観測されたプロジェクト（`codeCount>0`）
- **集合 S_lib（ライブラリ境界寄り集合）**: S_err のうち、エラーが出たファイルが **外部パッケージを import/require している**等のヒューリスティックにより、**ライブラリ呼び出し由来っぽい**と判定されたプロジェクト

### 7.3 確証（可能なら因果を強める）
上の集合を「依存の型欠如が原因」と強く言うには、単なるTSコード観測だけでなく **介入**を入れる。

- **確証の一例**: 対象依存に対して最小スタブ `.d.ts` を注入し、該当依存に起因する **TS7016 / （型宣言解決由来の）TS2307** が解消する  
  → これにより「型宣言が無い/解決できないことが主要因だった」をより強く主張できる。

補足（TypeWeaverとの位置づけ）:
- TypeWeaverは評価のノイズを減らすため、評価集合では **依存パッケージに型定義が存在することを保証（フィルタリング）**している。  
- 一方本研究は「依存ライブラリの `.d.ts` 整備」を主題とするため、Phase 0/1（型“解決”）ではむしろ **型定義欠如が観測される下流**を集める、という逆向きの集合設計が必要になる。

加えて、再現性と因果の説明のために、**fixtures（小規模・制御された下流）を少数用意**し、sanity checkとして併用する。  
（fixturesで「TS2307/TS7016が確実に解消される」ことを示し、実プロジェクトで「一般にどれだけ効くか」を示す。）

### 7.4 fixtures の配置（リポジトリ内）
- ルート: `evaluation-data-set/fixtures/`
- 現在用意している例: `evaluation-data-set/fixtures/error-TS7016/`（TS7016を確実に再現する下流・依存ライブラリ一式）

## 8. 研究フェーズ設計（エラーコードで追う）
本研究では「型推論ができているか」を、単に`tsc`が通ったかだけでなく、**エラーコードの“意味”を段階にマッピング**して追跡する。  
（複数エラーが同時に出ることを前提に、プロジェクトごとのエラー分布を集計する。）

### Phase 0（ゲート: 実験成立性と対象集合の確定）
Phase 0 は「型推論の改善」そのものではなく、**評価が成立する母集団を明示し、以後の議論の分母を固定する**ためのゲートである。

- **Gate A（実行ゲート: evaluation feasibility）**
  - **目的**: `tsc`（または `npm run typecheck`）が実行可能な形で、ログが取得できるプロジェクトのみを「観測対象」として扱う。
  - **代表的な脱落理由**:
    - `tsconfig` が repo ルートに無い（monorepo等）
    - install が失敗/タイムアウト（環境要因を含む）
  - **注記**: ここは研究対象（`.d.ts` 整備の効果）と独立した実務的条件のため、以後は「Gate A を通過した集合」を暗黙の母集団とする。

- **Gate B（対象集合ゲート: dataset membership）**
  - **集合 S_err（TSコード観測集合）**: `TSxxxx` が観測されたプロジェクト（`codeCount>0`）
  - **集合 S_lib（ライブラリ境界寄り集合）**: S_err のうち、エラー位置が外部パッケージ import/require を含む等のヒューリスティックで **ライブラリ由来っぽい**と判定されたプロジェクト
  - **目的**: 「型推論（`.d.ts` 整備）の効果」を議論する主評価母集団を S_lib として明示する（必要に応じて S_err を補助的に併記する）。

### Phase 1（型“解決”フェーズ: まず見えるようにする）
- **注目コード**: **TS2307 / TS7016**
- **成功条件（最低限）**: 注入後に、対象依存に起因する **TS2307/TS7016 が解消**する。
- **解釈**: ここは「型推論の質」よりも、**型宣言が解決可能な形で供給できたか**の評価。

### Phase 2（モジュール境界フェーズ: export/import形を合わせる）
- **注目コード（例）**:
  - **TS1192**: `Module has no default export`
  - **TS2614**: `Module has no exported member ...`
  - **TS2305**: `Module has no exported member ...`（観測上多い場合がある）
- **目的**: usage-drivenで抽出した import/require 形に対して、`.d.ts` の export 形を整合させる。

（fixturesでの具体例）
- default export が無いのに default import している場合: `import x from "m"` → `import { x } from "m"`
- default-only なのに named import している場合: `import { f } from "m"` → `import f from "m"`
- named export 名がズレている場合: `import { b } from "m"` → `import { a as b } from "m"` のように別名で整合させる

### Phase 3（API整合フェーズ: 型推論の“質”を評価）
- **注目コード（例）**:
  - **TS2339**（プロパティ/メソッド不存在）
  - **TS2345 / TS2322**（引数/代入の型不一致）
  - **TS2554 / TS2769**（引数個数/overload不一致）
  - **TS2353 / TS2741**（オブジェクトリテラルの過不足）
- **解釈**: Phase1/2が解消されたあとに、これらが増える/残る場合は「推論した型が使用実態とズレている」か「もともと下流の使い方が誤っている」可能性がある。  
  したがって、件数だけでなく **どのコードが増減したか（内訳）**で議論する。

### Phase 4（運用制約フェーズ: strictness-sensitive を副指標として追う）
TypeWeaverの示唆どおり「typecheckを通す」評価は重要だが、現実の下流は `tsconfig` の厳しさ（例: `noImplicitAny`）に左右される。  
この種のコードは `.d.ts` の“質”の議論と混ざりやすいため、**主評価（Phase 3）とは分けて副指標として追跡**する。

- **注目コード（例）**:
  - **TS7006 / TS7031**（暗黙any・分割代入の暗黙any等）
  - **TS1804**（未使用ローカル等、設定により error 扱いになり得る）
- **目的**: 「下流の運用（strictness）に耐える `.d.ts` をどの程度生成できるか」を補助的に把握する。

### Phase 5（残差分析: 失敗要因の抽出 = RQ3）
- **対象**: 注入後にも残った（または新規に顕在化した）エラー
- **目的**: 典型パターン（Promise/コールバック/動的アクセス/ジェネリクス等）と、対処可能性の整理。

## 9. 評価指標
### 9.1 主要指標（Primary）
- **`tsc`成功率**（プロジェクト単位 / ファイル単位）

### 9.2 追加分析（Secondary）
- **トリビアル型割合**: `.d.ts`内の`any`（必要なら`unknown`等も別枠）の比率（出現数比・行数比など）
- **エラー内訳**: TSエラーコード分布の条件間比較（特に Phase 1〜3 で指定したコード群）
- **フェーズ達成率（推奨）**:
  - Phase1達成率: 対象依存に起因するTS2307/TS7016が解消した割合
  - Phase2達成率: export/import不一致系（例: TS1192/TS2614）の解消割合
  - Phase3の変化: API整合系（例: TS2339/TS2345/TS2322/TS2769等）の増減と内訳

補足（TypeWeaverの示唆）:
- **プロジェクト（パッケージ）単位の成功率**は厳格で、1箇所の失敗で全体が失敗になるため、**ファイル単位の成功率**も併用すると「部分的にどこまで改善できたか」を議論しやすい。

## 10. 新規性（位置づけ）
本研究の新規性は、次の三点を一体として提示する点にある。
- **「下流の型検査を成立させるための、ライブラリ`.d.ts`自動整備」**に主眼を置く（library typingとしての問題設定）。
- **“型予測精度”ではなく“依存として使われたときの`tsc`成功”**で評価する（TypeWeaverの評価観点をライブラリ整備に適用）。
- **スタブ比較 + トリビアル率/エラー分布**により、「通す」以上の価値（安全性・有用性）を示す。

## 11. 想定される考察
- DTS_MODELが`tsc`成功率を改善する一方で、トリビアル型が増えるだけでないか。
- 改善が大きい/小さいライブラリ（API形状、コールバック多用、Promise多用等）の特徴。
- 増減するエラーコードのパターン（例: TS2307/TS7016が減り、TS2339などの型不整合が増える等）。

## 12. 妥当性への脅威（Threats to Validity）
- **外的妥当性**: 対象ライブラリ/下流の偏り（特定ドメインへの偏り）。
- **内的妥当性**: `tsc`失敗原因の切り分け（本研究はTS2307/TS7016を含むものに限定して担保）。
- **構成概念妥当性**: `tsc`成功が実行時安全性を保証しない点（ただし本研究の目的は型検査成立性の改善）。

## 13. スケジュール（案）
- fixtures整備（`evaluation-data-set/fixtures/`）とPhase設計の固定（追うエラーコード集合の確定）
- データセット収集（TS2307/TS7016起点）と、Phase1/2/3別の集計パイプラインの準備
- Usage-driven静的解析（evidence抽出）実装
- 条件ごとの`.d.ts`生成（DTS_STUB / DTS_MODEL）
- `tsc`評価・集計（成功率、トリビアル型割合、エラー分布、フェーズ達成率）
- 失敗ケース分析とまとめ（RQ1–RQ3）


